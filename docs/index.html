<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CatConway â€” Cellular Automata Explorer</title>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#0c0e14;--panel:#141822;--accent:#1c2333;--highlight:#c084fc;--text:#e2e8f0;--muted:#8892a8;--border:#2a3040;--alive:#6ee7b7;--dead:#1e293b;--chart-bg:#111827;--success:#34d399;--danger:#f87171}
body{background:var(--bg);color:var(--text);font-family:'Segoe UI',system-ui,sans-serif;overflow:hidden;height:100vh;display:flex;flex-direction:column}
header{background:var(--panel);padding:8px 16px;display:flex;align-items:center;gap:16px;border-bottom:1px solid var(--border);flex-wrap:wrap;z-index:10}
header h1{font-size:1.1rem;font-weight:700;white-space:nowrap}
header h1 span{color:var(--highlight)}
.controls{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
.controls label{font-size:.75rem;color:var(--muted)}
select,button,input[type=range]{font-size:.8rem;background:var(--accent);color:var(--text);border:1px solid var(--border);border-radius:4px;padding:4px 8px;cursor:pointer;outline:none;transition:background .15s,border-color .15s}
select{max-width:220px}
input[type=text]{font-size:.8rem;background:var(--accent);color:var(--text);border:1px solid var(--border);border-radius:4px;padding:4px 8px;outline:none;font-family:monospace;width:160px;transition:border-color .15s}
input[type=text]:focus{border-color:var(--highlight)}
input[type=text].invalid{border-color:#c0392b;background:#2c1a1a}
button:hover{background:var(--highlight);color:#fff}
button.active{background:var(--highlight);color:#fff}
input[type=range]{width:80px;padding:0;vertical-align:middle;accent-color:var(--highlight)}
.sep{width:1px;height:20px;background:var(--border);margin:0 4px}
#main-area{flex:1;display:flex;overflow:hidden}
#canvas-wrap{flex:1;position:relative;overflow:hidden}
canvas#c{display:block;width:100%;height:100%;image-rendering:pixelated}
#side-panel{width:280px;background:var(--panel);border-left:1px solid var(--border);display:flex;flex-direction:column;overflow-y:auto;flex-shrink:0}
#side-panel h2{font-size:.85rem;font-weight:600;padding:12px 14px 6px;color:var(--highlight);letter-spacing:.5px;text-transform:uppercase}
.stat-grid{display:grid;grid-template-columns:1fr 1fr;gap:1px;padding:0 10px 10px}
.stat-item{background:var(--accent);border-radius:6px;padding:8px 10px}
.stat-item .label{font-size:.65rem;color:var(--muted);text-transform:uppercase;letter-spacing:.3px}
.stat-item .value{font-size:1rem;font-weight:600;font-family:monospace;margin-top:2px}
.stat-item.wide{grid-column:1/-1}
#chart-wrap{padding:0 10px 10px;flex:1;min-height:0}
#pop-chart{width:100%;border-radius:6px;background:var(--chart-bg);border:1px solid var(--border)}
#info{position:absolute;bottom:8px;left:8px;font-size:.7rem;color:var(--muted);pointer-events:none;background:rgba(0,0,0,.6);padding:4px 8px;border-radius:4px}
#rule-display{position:absolute;top:8px;right:8px;font-size:.85rem;color:var(--highlight);background:rgba(0,0,0,.7);padding:6px 12px;border-radius:4px;font-family:monospace;pointer-events:none}
.tooltip{position:relative}
.tooltip::after{content:attr(data-tip);position:absolute;bottom:110%;left:50%;transform:translateX(-50%);background:#222;color:#ccc;font-size:.65rem;padding:3px 7px;border-radius:3px;white-space:nowrap;opacity:0;pointer-events:none;transition:opacity .15s}
.tooltip:hover::after{opacity:1}
</style>
</head>
<body>

<header>
  <h1>ğŸ± <span>Cat</span>Conway</h1>
  <div class="sep"></div>

  <div class="controls">
    <label>Rule:</label>
    <select id="rule-select"></select>
  </div>
  <div class="controls">
    <label>Custom:</label>
    <input type="text" id="custom-rule" placeholder="B3/S23 or B3-5/S4,8/R2" spellcheck="false" aria-label="Custom rule entry">
    <button id="btn-apply" class="tooltip" data-tip="Enter" aria-label="Apply custom rule">Apply</button>
  </div>
  <div class="sep"></div>

  <div class="controls">
    <button id="btn-play" class="tooltip active" data-tip="Space" aria-label="Play/Pause simulation">â–¶ Play</button>
    <button id="btn-step" class="tooltip" data-tip="Right Arrow" aria-label="Step one generation">â­ Step</button>
    <button id="btn-clear" class="tooltip" data-tip="C" aria-label="Clear grid">âŒ« Clear</button>
    <button id="btn-random" class="tooltip" data-tip="R" aria-label="Randomize grid">ğŸ² Random</button>
  </div>
  <div class="sep"></div>

  <div class="controls">
    <label>Speed:</label>
    <input type="range" id="speed" min="1" max="60" value="15">
    <span id="speed-val" style="font-size:.75rem;min-width:28px">15</span>
  </div>
  <div class="sep"></div>

  <div class="controls">
    <label>Pattern:</label>
    <select id="pattern-select">
      <option value="draw">âœï¸ Draw</option>
      <option value="glider">Glider</option>
      <option value="rpentomino">R-pentomino</option>
      <option value="acorn">Acorn</option>
      <option value="lwss">LWSS</option>
      <option value="gospergun">Gosper Gun</option>
    </select>
  </div>
  <div class="sep"></div>

  <div class="controls">
    <label>Grid:</label>
    <select id="grid-size">
      <option value="256">256Ã—256</option>
      <option value="512" selected>512Ã—512</option>
      <option value="1024">1024Ã—1024</option>
      <option value="2048">2048Ã—2048</option>
    </select>
  </div>
</header>

<div id="main-area">
<div id="canvas-wrap">
  <canvas id="c"></canvas>
  <div id="rule-display"></div>
  <div id="info"></div>
</div>

<div id="side-panel">
  <h2>ğŸ“Š Statistics</h2>
  <div class="stat-grid">
    <div class="stat-item"><div class="label">Generation</div><div class="value" id="stat-gen">0</div></div>
    <div class="stat-item"><div class="label">Population</div><div class="value" id="stat-pop">0</div></div>
    <div class="stat-item"><div class="label">Density</div><div class="value" id="stat-density">0%</div></div>
    <div class="stat-item"><div class="label">Gen/sec</div><div class="value" id="stat-gps">0</div></div>
    <div class="stat-item"><div class="label">Î” Population</div><div class="value" id="stat-delta">0</div></div>
    <div class="stat-item"><div class="label">Peak Pop</div><div class="value" id="stat-peak">0</div></div>
  </div>
  <h2>ğŸ“ˆ Population History</h2>
  <div id="chart-wrap">
    <canvas id="pop-chart" height="200"></canvas>
  </div>
  <h2>ğŸ” Behavior</h2>
  <div class="stat-grid">
    <div class="stat-item wide"><div class="label">Classification</div><div class="value" id="stat-class">Analyzing...</div></div>
    <div class="stat-item wide"><div class="label">Volatility</div><div class="value" id="stat-volatility">â€”</div></div>
  </div>
</div>
</div>

<script>
"use strict";

// â”€â”€ Rule Definitions (auto-generated from favorites.txt) â”€â”€â”€â”€â”€â”€â”€â”€â”€
const RULES = [
  // Favorites from favorites.txt
  {name:"â­ B3/S023", birth:[3], survival:[0, 2, 3], radius:1},
  {name:"â­ B3/S2378", birth:[3], survival:[2, 3, 7, 8], radius:1},
  {name:"â­ B3/S237", birth:[3], survival:[2, 3, 7], radius:1},
  {name:"â­ B3/S1256", birth:[3], survival:[1, 2, 5, 6], radius:1},
  {name:"â­ B345/S48", birth:[3, 4, 5], survival:[4, 8], radius:1},
  {name:"â­ B3/S12567", birth:[3], survival:[1, 2, 5, 6, 7], radius:1},
  {name:"â­ B0234/S012346", birth:[0, 2, 3, 4], survival:[0, 1, 2, 3, 4, 6], radius:1},
  {name:"â­ B01234/S02347", birth:[0, 1, 2, 3, 4], survival:[0, 2, 3, 4, 7], radius:1},
  {name:"â­ B01234/S246", birth:[0, 1, 2, 3, 4], survival:[2, 4, 6], radius:1},
];

// â”€â”€ Pattern Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PATTERNS = {
  glider:    {w:3,h:3,cells:[[1,0],[2,1],[0,2],[1,2],[2,2]]},
  rpentomino:{w:3,h:3,cells:[[1,0],[2,0],[0,1],[1,1],[1,2]]},
  acorn:     {w:7,h:3,cells:[[1,0],[3,1],[0,2],[1,2],[4,2],[5,2],[6,2]]},
  lwss:      {w:5,h:4,cells:[[1,0],[4,0],[0,1],[0,2],[4,2],[0,3],[1,3],[2,3],[3,3]]},
  gospergun: {w:36,h:9,cells:[
    [24,0],[22,1],[24,1],[12,2],[13,2],[20,2],[21,2],[34,2],[35,2],
    [11,3],[15,3],[20,3],[21,3],[34,3],[35,3],[0,4],[1,4],[10,4],
    [16,4],[20,4],[21,4],[0,5],[1,5],[10,5],[14,5],[16,5],[17,5],
    [22,5],[24,5],[10,6],[16,6],[24,6],[11,7],[15,7],[12,8],[13,8]
  ]},
};

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let gridSize   = 512;
let playing    = true;
let stepsPerSec= 15;
let generation = 0;
let population = 0;
let curRule    = RULES[0];
let camera     = {x:0, y:0, zoom:1};

// â”€â”€ Stats Tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MAX_HISTORY = 300;
let popHistory   = [];
let peakPop      = 0;
let lastGenTime  = performance.now();
let genPerSec    = 0;
let genCounter   = 0;
let lastGpsUpdate= performance.now();

// â”€â”€ WebGL2 Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2', {antialias:false, preserveDrawingBuffer:false});
if(!gl){document.body.innerHTML='<h2 style="color:red;padding:2rem">WebGL2 required but not available.</h2>';throw new Error('No WebGL2');}

gl.getExtension('EXT_color_buffer_float');

const quadVerts = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
const quadBuf   = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

// â”€â”€ Shader Sources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const VS = `#version 300 es
in vec2 a_pos;
out vec2 v_uv;
void main(){
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}`;

const SIM_FS = `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 fragColor;

uniform sampler2D u_state;
uniform vec2 u_size;
uniform int u_birth[26];
uniform int u_survival[26];
uniform int u_radius;

void main(){
  ivec2 coord = ivec2(gl_FragCoord.xy);
  int sz = int(u_size.x);
  float me = texelFetch(u_state, coord, 0).r;
  int neighbors = 0;
  for(int dy = -u_radius; dy <= u_radius; dy++){
    for(int dx = -u_radius; dx <= u_radius; dx++){
      if(dx == 0 && dy == 0) continue;
      ivec2 nc = (coord + ivec2(dx, dy) + ivec2(sz)) % ivec2(sz);
      neighbors += int(texelFetch(u_state, nc, 0).r > 0.5);
    }
  }
  float alive;
  if(me > 0.5){
    alive = float(u_survival[neighbors]);
  } else {
    alive = float(u_birth[neighbors]);
  }
  fragColor = vec4(alive, alive, alive, 1.0);
}`;

const RENDER_FS = `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 fragColor;

uniform sampler2D u_state;
uniform vec2 u_resolution;
uniform vec2 u_gridSize;
uniform vec2 u_camera;
uniform float u_zoom;

void main(){
  vec2 aspect = u_resolution / min(u_resolution.x, u_resolution.y);
  vec2 gridUV = (v_uv - 0.5) * aspect / u_zoom + 0.5 + u_camera / u_gridSize;
  gridUV = fract(gridUV);
  float cell = texture(u_state, gridUV).r;

  vec3 alive_color = vec3(0.43, 0.91, 0.72);
  vec3 dead_color  = vec3(0.05, 0.07, 0.11);
  vec3 col = mix(dead_color, alive_color, cell);

  vec2 gridCoord = gridUV * u_gridSize;
  vec2 gridFrac = fract(gridCoord);
  float lineWidth = 0.03 * u_zoom;
  if(u_zoom > 3.0){
    float grid_line = step(gridFrac.x, lineWidth) + step(gridFrac.y, lineWidth);
    col = mix(col, vec3(0.18, 0.20, 0.28), min(grid_line, 1.0) * 0.5);
  }

  fragColor = vec4(col, 1.0);
}`;

// â”€â”€ Shader Compilation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createShader(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
    gl.deleteShader(s);
    return null;
  }
  return s;
}

function createProgram(vsSrc, fsSrc){
  const vs = createShader(gl.VERTEX_SHADER, vsSrc);
  const fs = createShader(gl.FRAGMENT_SHADER, fsSrc);
  const p  = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p));
    return null;
  }
  return p;
}

const simProg    = createProgram(VS, SIM_FS);
const renderProg = createProgram(VS, RENDER_FS);

const simUni = {
  state:    gl.getUniformLocation(simProg, 'u_state'),
  size:     gl.getUniformLocation(simProg, 'u_size'),
  birth:    [],
  survival: [],
  radius:   gl.getUniformLocation(simProg, 'u_radius'),
};
for(let i=0;i<26;i++){
  simUni.birth.push(gl.getUniformLocation(simProg, `u_birth[${i}]`));
  simUni.survival.push(gl.getUniformLocation(simProg, `u_survival[${i}]`));
}

const renUni = {
  state:      gl.getUniformLocation(renderProg, 'u_state'),
  resolution: gl.getUniformLocation(renderProg, 'u_resolution'),
  gridSize:   gl.getUniformLocation(renderProg, 'u_gridSize'),
  camera:     gl.getUniformLocation(renderProg, 'u_camera'),
  zoom:       gl.getUniformLocation(renderProg, 'u_zoom'),
};

// â”€â”€ Framebuffers (ping-pong) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let texA, texB, fboA, fboB;

function createStateTexture(size, data){
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, size, size, 0, gl.RED, gl.FLOAT, data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  return tex;
}

function createFBO(tex){
  const fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  return fbo;
}

function initBuffers(size, data){
  if(texA) gl.deleteTexture(texA);
  if(texB) gl.deleteTexture(texB);
  if(fboA) gl.deleteFramebuffer(fboA);
  if(fboB) gl.deleteFramebuffer(fboB);
  texA = createStateTexture(size, data || null);
  texB = createStateTexture(size, null);
  fboA = createFBO(texA);
  fboB = createFBO(texB);
}

// â”€â”€ Grid State Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function randomGrid(){
  const data = new Float32Array(gridSize * gridSize);
  const density = curRule.radius === 2 ? 0.4 : 0.3;
  for(let i = 0; i < data.length; i++) data[i] = Math.random() < density ? 1.0 : 0.0;
  return data;
}

function clearGrid(){
  return new Float32Array(gridSize * gridSize);
}

function stampPattern(data, pattern, cx, cy){
  const p = PATTERNS[pattern];
  if(!p) return;
  const ox = cx - Math.floor(p.w/2);
  const oy = cy - Math.floor(p.h/2);
  for(const [px,py] of p.cells){
    const x = ((ox + px) % gridSize + gridSize) % gridSize;
    const y = ((oy + py) % gridSize + gridSize) % gridSize;
    data[y * gridSize + x] = 1.0;
  }
}

function uploadState(data){
  gl.bindTexture(gl.TEXTURE_2D, texA);
  gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gridSize, gridSize, gl.RED, gl.FLOAT, data);
}

function readState(){
  gl.bindFramebuffer(gl.FRAMEBUFFER, fboA);
  const data = new Float32Array(gridSize * gridSize * 4);
  gl.readPixels(0, 0, gridSize, gridSize, gl.RGBA, gl.FLOAT, data);
  const state = new Float32Array(gridSize * gridSize);
  for(let i = 0; i < state.length; i++) state[i] = data[i*4];
  return state;
}

// â”€â”€ Simulation Step â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupQuad(prog){
  const loc = gl.getAttribLocation(prog, 'a_pos');
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
}

function simStep(){
  gl.viewport(0, 0, gridSize, gridSize);
  gl.bindFramebuffer(gl.FRAMEBUFFER, fboB);
  gl.useProgram(simProg);
  setupQuad(simProg);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texA);
  gl.uniform1i(simUni.state, 0);
  gl.uniform2f(simUni.size, gridSize, gridSize);
  gl.uniform1i(simUni.radius, curRule.radius);

  const maxN = curRule.radius === 2 ? 24 : 8;
  for(let i = 0; i < 26; i++){
    gl.uniform1i(simUni.birth[i], curRule.birth.includes(i) && i <= maxN ? 1 : 0);
    gl.uniform1i(simUni.survival[i], curRule.survival.includes(i) && i <= maxN ? 1 : 0);
  }

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  [texA, texB] = [texB, texA];
  [fboA, fboB] = [fboB, fboA];
  generation++;
}

// â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render(){
  const w = canvas.width;
  const h = canvas.height;
  gl.viewport(0, 0, w, h);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.useProgram(renderProg);
  setupQuad(renderProg);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texA);
  gl.uniform1i(renUni.state, 0);
  gl.uniform2f(renUni.resolution, w, h);
  gl.uniform2f(renUni.gridSize, gridSize, gridSize);
  gl.uniform2f(renUni.camera, camera.x, camera.y);
  gl.uniform1f(renUni.zoom, camera.zoom);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// â”€â”€ Population Count â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function countPopulation(){
  gl.bindFramebuffer(gl.FRAMEBUFFER, fboA);
  const sampleSize = Math.min(gridSize, 256);
  const data = new Float32Array(sampleSize * sampleSize * 4);
  gl.readPixels(0, 0, sampleSize, sampleSize, gl.RGBA, gl.FLOAT, data);
  let count = 0;
  for(let i = 0; i < sampleSize * sampleSize; i++){
    if(data[i*4] > 0.5) count++;
  }
  population = Math.round(count * (gridSize * gridSize) / (sampleSize * sampleSize));
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

// â”€â”€ Minimum Zoom (prevent grid replication) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getMinZoom(){
  const w = canvas.width || 1;
  const h = canvas.height || 1;
  return Math.max(w, h) / Math.min(w, h);
}

function clampZoom(z){
  return Math.max(getMinZoom(), Math.min(z, 50));
}

// â”€â”€ Population Chart Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const chartCanvas = document.getElementById('pop-chart');
const chartCtx    = chartCanvas.getContext('2d');

function drawChart(){
  const rect = chartCanvas.parentElement.getBoundingClientRect();
  const dpr  = window.devicePixelRatio || 1;
  const cw   = Math.round(rect.width * dpr);
  const ch   = Math.round(200 * dpr);
  if(chartCanvas.width !== cw || chartCanvas.height !== ch){
    chartCanvas.width  = cw;
    chartCanvas.height = ch;
    chartCanvas.style.height = '200px';
  }

  const ctx = chartCtx;
  const w = chartCanvas.width;
  const h = chartCanvas.height;
  const pad = {top:20*dpr, right:10*dpr, bottom:25*dpr, left:50*dpr};
  const plotW = w - pad.left - pad.right;
  const plotH = h - pad.top - pad.bottom;

  ctx.clearRect(0, 0, w, h);

  // Background
  ctx.fillStyle = '#111827';
  ctx.fillRect(0, 0, w, h);

  if(popHistory.length < 2) {
    ctx.fillStyle = '#8892a8';
    ctx.font = `${11*dpr}px system-ui`;
    ctx.textAlign = 'center';
    ctx.fillText('Collecting data...', w/2, h/2);
    return;
  }

  const totalCells = gridSize * gridSize;
  const maxPop = Math.max(peakPop, 1);

  // Grid lines
  ctx.strokeStyle = '#1e293b';
  ctx.lineWidth = dpr;
  const gridLines = 4;
  for(let i = 0; i <= gridLines; i++){
    const y = pad.top + (plotH * i / gridLines);
    ctx.beginPath();
    ctx.moveTo(pad.left, y);
    ctx.lineTo(pad.left + plotW, y);
    ctx.stroke();
  }

  // Y-axis labels
  ctx.fillStyle = '#8892a8';
  ctx.font = `${9*dpr}px monospace`;
  ctx.textAlign = 'right';
  for(let i = 0; i <= gridLines; i++){
    const y = pad.top + (plotH * i / gridLines);
    const val = maxPop * (1 - i / gridLines);
    const label = val >= 1000 ? (val/1000).toFixed(1)+'k' : Math.round(val).toString();
    ctx.fillText(label, pad.left - 5*dpr, y + 3*dpr);
  }

  // X-axis label
  ctx.textAlign = 'center';
  ctx.fillText('Generation', pad.left + plotW/2, h - 3*dpr);

  // Plot alive line
  ctx.beginPath();
  ctx.strokeStyle = '#6ee7b7';
  ctx.lineWidth = 1.5*dpr;
  for(let i = 0; i < popHistory.length; i++){
    const x = pad.left + (i / (popHistory.length - 1)) * plotW;
    const y = pad.top + plotH - (popHistory[i] / maxPop) * plotH;
    if(i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Fill under alive line
  ctx.lineTo(pad.left + plotW, pad.top + plotH);
  ctx.lineTo(pad.left, pad.top + plotH);
  ctx.closePath();
  ctx.fillStyle = 'rgba(110, 231, 183, 0.08)';
  ctx.fill();

  // Plot dead line
  ctx.beginPath();
  ctx.strokeStyle = '#f8717180';
  ctx.lineWidth = 1*dpr;
  for(let i = 0; i < popHistory.length; i++){
    const x = pad.left + (i / (popHistory.length - 1)) * plotW;
    const dead = totalCells - popHistory[i];
    const y = pad.top + plotH - (dead / maxPop) * plotH;
    if(i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Legend
  const legendY = 12*dpr;
  ctx.font = `${9*dpr}px system-ui`;
  ctx.textAlign = 'left';
  ctx.fillStyle = '#6ee7b7';
  ctx.fillRect(pad.left, legendY - 5*dpr, 10*dpr, 3*dpr);
  ctx.fillText('Alive', pad.left + 14*dpr, legendY);
  const aliveTextW = ctx.measureText('Alive').width;
  ctx.fillStyle = '#f87171';
  ctx.fillRect(pad.left + 20*dpr + aliveTextW, legendY - 5*dpr, 10*dpr, 3*dpr);
  ctx.fillStyle = '#f8717180';
  ctx.fillText('Dead', pad.left + 34*dpr + aliveTextW, legendY);
}

// â”€â”€ Stats Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateStats(){
  const totalCells = gridSize * gridSize;
  const density = totalCells > 0 ? (population / totalCells * 100) : 0;
  const lastPop = popHistory.length >= 2 ? popHistory[popHistory.length - 2] : population;
  const delta = population - lastPop;

  document.getElementById('stat-gen').textContent = generation.toLocaleString();
  document.getElementById('stat-pop').textContent = population.toLocaleString();
  document.getElementById('stat-density').textContent = density.toFixed(1) + '%';
  document.getElementById('stat-gps').textContent = genPerSec.toFixed(0);
  document.getElementById('stat-delta').textContent = (delta >= 0 ? '+' : '') + delta.toLocaleString();
  document.getElementById('stat-delta').style.color = delta > 0 ? 'var(--success)' : delta < 0 ? 'var(--danger)' : 'var(--text)';
  document.getElementById('stat-peak').textContent = peakPop.toLocaleString();

  // Behavior classification
  classifyBehavior();
}

function classifyBehavior(){
  const el = document.getElementById('stat-class');
  const volEl = document.getElementById('stat-volatility');

  if(popHistory.length < 30){
    el.textContent = 'Analyzing...';
    el.style.color = 'var(--muted)';
    volEl.textContent = 'â€”';
    return;
  }

  // Compute recent volatility (coefficient of variation of last 50 samples)
  const recent = popHistory.slice(-50);
  const mean = recent.reduce((a,b) => a+b, 0) / recent.length;
  const variance = recent.reduce((a,b) => a + (b - mean)**2, 0) / recent.length;
  const stdDev = Math.sqrt(variance);
  const cv = mean > 0 ? (stdDev / mean * 100) : 0;

  volEl.textContent = cv.toFixed(1) + '%';

  // Check for period: search for repeating patterns in recent history
  const last100 = popHistory.slice(-100);
  let detectedPeriod = 0;
  for(let period = 1; period <= 20; period++){
    let match = true;
    let checks = 0;
    for(let i = last100.length - 1; i >= period && checks < period * 3; i--){
      if(Math.abs(last100[i] - last100[i - period]) > population * 0.01){
        match = false;
        break;
      }
      checks++;
    }
    if(match && checks >= period * 2){
      detectedPeriod = period;
      break;
    }
  }

  if(population === 0){
    el.textContent = 'ğŸ’€ Extinct';
    el.style.color = 'var(--danger)';
  } else if(detectedPeriod === 1){
    el.textContent = 'ğŸ”’ Stable';
    el.style.color = 'var(--success)';
  } else if(detectedPeriod > 1){
    el.textContent = `ğŸ”„ Periodic (T=${detectedPeriod})`;
    el.style.color = '#c084fc';
  } else if(cv < 2){
    el.textContent = 'ğŸ“ Quasi-stable';
    el.style.color = 'var(--success)';
  } else if(cv < 10){
    el.textContent = 'ğŸŒŠ Oscillating';
    el.style.color = '#fbbf24';
  } else {
    el.textContent = 'ğŸŒ€ Chaotic';
    el.style.color = 'var(--danger)';
  }
}

// â”€â”€ Main Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastStep = 0;
let chartTimer = 0;
function mainLoop(now){
  requestAnimationFrame(mainLoop);

  const rect = canvas.parentElement.getBoundingClientRect();
  const dpr  = window.devicePixelRatio || 1;
  const cw   = Math.round(rect.width * dpr);
  const ch   = Math.round(rect.height * dpr);
  if(canvas.width !== cw || canvas.height !== ch){
    canvas.width  = cw;
    canvas.height = ch;
    camera.zoom = clampZoom(camera.zoom);
  }

  if(playing){
    const interval = 1000 / stepsPerSec;
    if(now - lastStep >= interval){
      simStep();
      lastStep = now;
      genCounter++;
    }
  }

  // Gen/sec tracking
  if(now - lastGpsUpdate >= 1000){
    genPerSec = genCounter * 1000 / (now - lastGpsUpdate);
    genCounter = 0;
    lastGpsUpdate = now;
  }

  render();

  if(generation % 10 === 0 && generation > 0){
    countPopulation();
    if(popHistory.length === 0 || popHistory[popHistory.length-1] !== population || popHistory.length < MAX_HISTORY){
      popHistory.push(population);
      if(popHistory.length > MAX_HISTORY) popHistory.shift();
      peakPop = Math.max(peakPop, population);
    }
  }

  // Update stats & chart at ~10fps
  if(now - chartTimer > 100){
    updateStats();
    drawChart();
    chartTimer = now;
  }

  const info = document.getElementById('info');
  info.textContent = `Gen: ${generation} | Pop: ~${population.toLocaleString()} | Grid: ${gridSize}\u00d7${gridSize} | Zoom: ${camera.zoom.toFixed(1)}x`;
}

// â”€â”€ Screen â†’ Grid Coordinate Mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function screenToGrid(sx, sy){
  const rect = canvas.getBoundingClientRect();
  const dpr  = window.devicePixelRatio || 1;
  const w = rect.width * dpr;
  const h = rect.height * dpr;
  const px = (sx - rect.left) * dpr;
  const py = (sy - rect.top) * dpr;

  const uvx = px / w;
  const uvy = 1.0 - py / h;
  const minDim = Math.min(w, h);
  const ax = w / minDim;
  const ay = h / minDim;
  let gx = (uvx - 0.5) * ax / camera.zoom + 0.5 + camera.x / gridSize;
  let gy = (uvy - 0.5) * ay / camera.zoom + 0.5 + camera.y / gridSize;
  gx = ((gx % 1) + 1) % 1;
  gy = ((gy % 1) + 1) % 1;
  return [Math.floor(gx * gridSize), Math.floor(gy * gridSize)];
}

// â”€â”€ UI Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ruleSelect    = document.getElementById('rule-select');
const patternSelect = document.getElementById('pattern-select');
const gridSizeSelect= document.getElementById('grid-size');
const speedSlider   = document.getElementById('speed');
const speedVal      = document.getElementById('speed-val');
const ruleDisplay   = document.getElementById('rule-display');
const btnPlay       = document.getElementById('btn-play');

RULES.forEach((r,i) => {
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = r.name;
  ruleSelect.appendChild(opt);
});
ruleSelect.value = 0;

// â”€â”€ Custom Rule Parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function parseRuleString(str){
  str = str.trim().toUpperCase();
  const m = str.match(/^B([\d,-]*)\s*\/\s*S([\d,-]*)(?:\s*\/\s*R(\d+))?$/);
  if(!m) return null;
  function parseNums(s){
    if(!s) return [];
    const nums = [];
    for(const part of s.split(',')){
      const range = part.match(/^(\d+)-(\d+)$/);
      if(range){
        const lo = parseInt(range[1]), hi = parseInt(range[2]);
        for(let i = lo; i <= hi; i++) nums.push(i);
      } else if(/^\d+$/.test(part)){
        nums.push(parseInt(part));
      } else { return null; }
    }
    return [...new Set(nums)].sort((a,b)=>a-b);
  }
  const birth = parseNums(m[1]);
  const survival = parseNums(m[2]);
  if(!birth || !survival) return null;
  const radius = m[3] ? parseInt(m[3]) : 1;
  if(radius < 1 || radius > 2) return null;
  const maxN = radius === 2 ? 24 : 8;
  if(birth.some(n => n < 0 || n > maxN) || survival.some(n => n < 0 || n > maxN)) return null;
  const b = birth.join('');
  const s = survival.join('');
  const r = radius > 1 ? `/R${radius}` : '';
  return {name:`B${b}/S${s}${r}`, birth, survival, radius};
}

const customInput = document.getElementById('custom-rule');
const btnApply    = document.getElementById('btn-apply');

function applyCustomRule(){
  const rule = parseRuleString(customInput.value);
  if(rule){
    customInput.classList.remove('invalid');
    curRule = rule;
    ruleSelect.value = '';
    resetSim(false);
  } else {
    customInput.classList.add('invalid');
  }
}

btnApply.addEventListener('click', applyCustomRule);
customInput.addEventListener('keydown', (e) => {
  if(e.key === 'Enter'){ e.preventDefault(); applyCustomRule(); }
});
customInput.addEventListener('input', () => customInput.classList.remove('invalid'));

function updateRuleDisplay(){
  const b = curRule.birth.join('');
  const s = curRule.survival.join('');
  const r = curRule.radius > 1 ? `/R${curRule.radius}` : '';
  ruleDisplay.textContent = `B${b}/S${s}${r}`;
}

function resetSim(keepState){
  generation = 0;
  population = 0;
  popHistory = [];
  peakPop = 0;
  genCounter = 0;
  if(!keepState){
    const data = randomGrid();
    initBuffers(gridSize, data);
  }
  updateRuleDisplay();
}

ruleSelect.addEventListener('change', () => {
  const idx = parseInt(ruleSelect.value);
  if(!isNaN(idx) && RULES[idx]){
    curRule = RULES[idx];
    customInput.value = '';
    customInput.classList.remove('invalid');
    resetSim(false);
  }
});

gridSizeSelect.addEventListener('change', () => {
  gridSize = parseInt(gridSizeSelect.value);
  camera = {x:0, y:0, zoom:clampZoom(1)};
  resetSim(false);
});

speedSlider.addEventListener('input', () => {
  stepsPerSec = parseInt(speedSlider.value);
  speedVal.textContent = stepsPerSec;
});

btnPlay.addEventListener('click', () => {
  playing = !playing;
  btnPlay.textContent = playing ? '\u25b6 Play' : '\u23f8 Pause';
  btnPlay.classList.toggle('active', playing);
});

document.getElementById('btn-step').addEventListener('click', () => {
  if(playing){ playing = false; btnPlay.textContent = '\u25b6 Play'; btnPlay.classList.remove('active'); }
  simStep();
});

document.getElementById('btn-clear').addEventListener('click', () => {
  generation = 0;
  population = 0;
  popHistory = [];
  peakPop = 0;
  genCounter = 0;
  initBuffers(gridSize, clearGrid());
});

document.getElementById('btn-random').addEventListener('click', () => {
  resetSim(false);
});

// â”€â”€ Mouse/Touch Interaction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let dragging = false;
let drawing  = false;
let lastMouse= {x:0,y:0};

canvas.addEventListener('mousedown', (e) => {
  if(e.button === 1 || e.button === 2 || e.shiftKey){
    dragging = true;
    lastMouse = {x:e.clientX, y:e.clientY};
    e.preventDefault();
  } else if(e.button === 0){
    const [gx, gy] = screenToGrid(e.clientX, e.clientY);
    const pat = patternSelect.value;
    if(pat === 'draw'){
      drawing = true;
      const state = readState();
      const idx = gy * gridSize + gx;
      state[idx] = state[idx] > 0.5 ? 0.0 : 1.0;
      uploadState(state);
    } else {
      const state = readState();
      stampPattern(state, pat, gx, gy);
      uploadState(state);
    }
  }
});

canvas.addEventListener('mousemove', (e) => {
  if(dragging){
    const dx = e.clientX - lastMouse.x;
    const dy = e.clientY - lastMouse.y;
    const dpr = window.devicePixelRatio || 1;
    const minDim = Math.min(canvas.width, canvas.height);
    camera.x -= dx * dpr * gridSize / (minDim * camera.zoom);
    camera.y += dy * dpr * gridSize / (minDim * camera.zoom);
    lastMouse = {x:e.clientX, y:e.clientY};
  } else if(drawing){
    const [gx, gy] = screenToGrid(e.clientX, e.clientY);
    const state = readState();
    state[gy * gridSize + gx] = 1.0;
    uploadState(state);
  }
});

canvas.addEventListener('mouseup', () => { dragging = false; drawing = false; });
canvas.addEventListener('mouseleave', () => { dragging = false; drawing = false; });
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const factor = e.deltaY < 0 ? 1.15 : 1/1.15;
  camera.zoom = clampZoom(camera.zoom * factor);
}, {passive:false});

// â”€â”€ Keyboard Shortcuts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('keydown', (e) => {
  if(e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') return;
  switch(e.code){
    case 'Space':
      e.preventDefault();
      btnPlay.click();
      break;
    case 'ArrowRight':
      document.getElementById('btn-step').click();
      break;
    case 'KeyC':
      document.getElementById('btn-clear').click();
      break;
    case 'KeyR':
      document.getElementById('btn-random').click();
      break;
    case 'Equal': case 'NumpadAdd':
      camera.zoom = Math.min(camera.zoom * 1.2, 50);
      break;
    case 'Minus': case 'NumpadSubtract':
      camera.zoom = clampZoom(camera.zoom / 1.2);
      break;
    case 'Home':
      camera = {x:0, y:0, zoom:1};
      break;
  }
});

// â”€â”€ Touch Support â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTouches = [];
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  lastTouches = Array.from(e.touches);
  if(e.touches.length === 1){
    const t = e.touches[0];
    const [gx, gy] = screenToGrid(t.clientX, t.clientY);
    const pat = patternSelect.value;
    if(pat === 'draw'){
      drawing = true;
      const state = readState();
      const idx = gy * gridSize + gx;
      state[idx] = state[idx] > 0.5 ? 0.0 : 1.0;
      uploadState(state);
    } else {
      const state = readState();
      stampPattern(state, pat, gx, gy);
      uploadState(state);
    }
  }
}, {passive:false});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if(e.touches.length === 1 && drawing){
    const t = e.touches[0];
    const [gx, gy] = screenToGrid(t.clientX, t.clientY);
    const state = readState();
    state[gy * gridSize + gx] = 1.0;
    uploadState(state);
  } else if(e.touches.length === 2){
    drawing = false;
    const cur = Array.from(e.touches);
    const prevDist = Math.hypot(lastTouches[1].clientX - lastTouches[0].clientX, lastTouches[1].clientY - lastTouches[0].clientY);
    const curDist  = Math.hypot(cur[1].clientX - cur[0].clientX, cur[1].clientY - cur[0].clientY);
    if(prevDist > 0) camera.zoom = clampZoom(camera.zoom * (curDist / prevDist));
    const prevMid = {x:(lastTouches[0].clientX+lastTouches[1].clientX)/2, y:(lastTouches[0].clientY+lastTouches[1].clientY)/2};
    const curMid  = {x:(cur[0].clientX+cur[1].clientX)/2, y:(cur[0].clientY+cur[1].clientY)/2};
    const dpr = window.devicePixelRatio || 1;
    const minDim = Math.min(canvas.width, canvas.height);
    camera.x -= (curMid.x - prevMid.x) * dpr * gridSize / (minDim * camera.zoom);
    camera.y += (curMid.y - prevMid.y) * dpr * gridSize / (minDim * camera.zoom);
    lastTouches = cur;
  }
}, {passive:false});

canvas.addEventListener('touchend', () => { drawing = false; lastTouches = []; });

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
resetSim(false);
updateRuleDisplay();
requestAnimationFrame(mainLoop);
</script>
</body>
</html>